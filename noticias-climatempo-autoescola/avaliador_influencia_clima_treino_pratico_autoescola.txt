<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Previs√£o e Planejamento de Aulas</title>
    <!-- Carregando Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carregando a fonte Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Aplicando a fonte Inter como padr√£o */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilo para o spinner de carregamento */
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- Container principal do m√≥dulo -->
    <div class="w-full max-w-4xl bg-white rounded-2xl shadow-xl p-6 md:p-8">
        
        <!-- Cabe√ßalho -->
        <header class="mb-6">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">
                Previs√£o do Tempo e Planejamento de Aulas Pr√°ticas
            </h1>
            <p class="text-gray-500 mt-1">
                Insira uma localiza√ß√£o para ver a previs√£o e recomenda√ß√µes para atividades ao ar livre.
            </p>
        </header>

        <!-- Se√ß√£o de Busca -->
        <div class="flex flex-col sm:flex-row gap-3 mb-6">
            <input 
                type="text" 
                id="locationInput"
                placeholder="Ex: S√£o Paulo, BR"
                class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
            >
            <button 
                id="searchButton"
                class="bg-blue-600 text-white font-semibold px-6 py-3 rounded-lg hover:bg-blue-700 transition-all duration-200 shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
            >
                Buscar Previs√£o
            </button>
        </div>

        <!-- √Årea de Conte√∫do (Resultados) -->
        <div id="resultsContainer">
            
            <!-- Estado de Carregamento -->
            <div id="loader" class="flex justify-center items-center py-10 hidden">
                <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-12 w-12"></div>
                <p class="ml-4 text-gray-600">Buscando previs√£o...</p>
            </div>

            <!-- Estado de Erro -->
            <div id="errorMessage" class="text-center p-6 bg-red-50 border border-red-200 text-red-700 rounded-lg hidden">
                <p id="errorText"></p>
            </div>

            <!-- Estado Inicial / Boas-vindas -->
            <div id="welcomeMessage" class="text-center p-6 bg-blue-50 border border-blue-200 text-blue-700 rounded-lg">
                <p>Por favor, insira uma localiza√ß√£o para come√ßar.</p>
                <p class="text-sm mt-2">
                    <strong>Nota:</strong> Esta ferramenta usa a API OpenWeatherMap. Voc√™ deve 
                    <a href="https://openweathermap.org/appid" target="_blank" class="text-blue-600 underline hover:text-blue-800">
                        registrar e inserir sua pr√≥pria chave de API
                    </a> 
                    no c√≥digo (vari√°vel `apiKey`) para funcionar.
                </p>
            </div>

            <!-- Resultados da Previs√£o -->
            <div id="forecastContainer" class="hidden">
                <h2 class="text-xl font-bold text-gray-700 mb-4" id="locationTitle"></h2>
                
                <!-- Grid responsivo para os dias -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
                    <!-- Os cart√µes dos dias ser√£o inseridos aqui pelo JavaScript -->
                </div>
            </div>

        </div>

    </div>

    <script>
        // --- CHAVE DA API (IMPORTANTE) ---
        // Obtenha sua chave de API gratuita em https://openweathermap.org/appid
        const apiKey = "a20a6eac94fbbb7f3cafade4a7717db0"; 

        // --- SELE√á√ÉO DE ELEMENTOS DO DOM ---
        const locationInput = document.getElementById('locationInput');
        // ... (restante dos seletores) ...
        const searchButton = document.getElementById('searchButton');
        const resultsContainer = document.getElementById('resultsContainer');
        const loader = document.getElementById('loader');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const welcomeMessage = document.getElementById('welcomeMessage');
        const forecastContainer = document.getElementById('forecastContainer');
        const locationTitle = document.getElementById('locationTitle');

        // --- MANIPULADOR DE EVENTOS ---
        searchButton.addEventListener('click', handleSearch);
        locationInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSearch();
            }
        });

        /**
         * Fun√ß√£o principal que orquestra a busca.
         */
        async function handleSearch() {
            const location = locationInput.value.trim();
            
            if (!location) {
                showError("Por favor, insira um nome de localiza√ß√£o v√°lido.");
                return;
            }

            if (apiKey === "SEU_API_KEY_AQUI") {
                showError("Por favor, insira sua chave de API do OpenWeatherMap no c√≥digo (vari√°vel 'apiKey') para continuar.");
                welcomeMessage.classList.add('hidden');
                return;
            }

            // 1. Resetar UI
            showLoading(true);
            showError(null);
            welcomeMessage.classList.add('hidden');
            forecastContainer.classList.add('hidden');

            try {
                // 2. Buscar dados reais da API
                const rawData = await fetchRealWeather(location);
                
                // 3. Processar e formatar os dados
                const weatherData = processWeatherData(rawData);

                // 4. Renderizar resultados
                renderForecast(weatherData);

            } catch (error) {
                // 5. Lidar com erros
                showError(error.message);
            } finally {
                // 6. Parar carregamento
                showLoading(false);
            }
        }

        /**
         * Controla a exibi√ß√£o do spinner de carregamento.
         */
        function showLoading(isLoading) {
            // ... (fun√ß√£o inalterada) ...
            if (isLoading) {
                loader.classList.remove('hidden');
            } else {
                loader.classList.add('hidden');
            }
        }

        /**
         * Mostra uma mensagem de erro na UI.
         */
        function showError(message) {
            // ... (fun√ß√£o inalterada) ...
            if (message) {
                errorText.textContent = message;
                errorMessage.classList.remove('hidden');
            } else {
                errorMessage.classList.add('hidden');
            }
        }

        /**
         * Renderiza os dados da previs√£o na tela.
         */
        function renderForecast(data) {
            // ... (fun√ß√£o inalterada) ...
            locationTitle.textContent = `Previs√£o para ${data.locationName}`;
            
            const gridContainer = forecastContainer.querySelector('.grid');
            gridContainer.innerHTML = '';

            data.forecast.forEach(day => {
                const recommendation = getRecommendation(day);
                const card = createDayCard(day, recommendation);
                gridContainer.appendChild(card);
            });

            forecastContainer.classList.remove('hidden');
        }

        /**
         * Cria o elemento HTML para o cart√£o de um dia.
         */
        function createDayCard(day, recommendation) {
            // ... (fun√ß√£o inalterada) ...
            const card = document.createElement('div');
            card.className = `border rounded-lg p-4 bg-white shadow-sm flex flex-col ${recommendation.borderColor} border-l-4`;

            card.innerHTML = `
                <div class="flex-grow">
                    <p class="font-bold text-lg text-gray-800">${day.weekday}</p>
                    <p class="text-sm text-gray-500 mb-3">${day.date}</p>
                    
                    <div class="text-4xl text-center my-4">${getWeatherIcon(day.condition)}</div>
                    
                    <p class="text-2xl font-bold text-center text-gray-800">${day.temp_max}¬∞C</p>
                    <p class="text-center text-gray-500 mb-4">Min: ${day.temp_min}¬∞C</p>

                    <div class="space-y-2 text-sm mb-4">
                        <p class="text-gray-700">‚òî Precipita√ß√£o: <strong>${day.precipitation}%</strong></p>
                        <p class="text-gray-700">üí® Vento: <strong>${day.wind_speed} km/h</strong></p>
                        <p class="text-gray-700">üëÅÔ∏è Visibilidade: <strong>${getVisibilityCategory(day.visibility)}</strong></p>
                    </div>

                    <!-- Recomenda√ß√£o -->
                    <div class="p-2 rounded-md text-center font-semibold ${recommendation.bgColor} ${recommendation.textColor}">
                        ${recommendation.text}
                    </div>
                </div>
                
                <!-- Planejamento (Notas) -->
                <div class="mt-4 pt-4 border-t">
                    <label class="text-sm font-medium text-gray-600 mb-1 block">Notas da Aula:</label>
                    <textarea 
                        class="w-full p-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-blue-400" 
                        rows="3" 
                        placeholder="Ex: Aula de biologia no p√°tio..."
                    ></textarea>
                </div>
            `;
            return card;
        }


        // --- L√ìGICA DE NEG√ìCIO E DADOS DA API ---

        /**
         * Busca dados reais da API OpenWeatherMap (Previs√£o de 5 dias / 3 horas).
         * @param {string} location - O nome da localiza√ß√£o.
         * @returns {Promise<object>} - Uma promessa que resolve com os dados brutos da API.
         */
        async function fetchRealWeather(location) {
            const apiUrl = `https://api.openweathermap.org/data/2.5/forecast?q=${location}&appid=${apiKey}&units=metric&lang=pt_br`;

            const response = await fetch(apiUrl);

            if (!response.ok) {
                if (response.status === 401) {
                    throw new Error("Chave de API inv√°lida ou n√£o autorizada. Verifique sua chave no c√≥digo.");
                }
                if (response.status === 404) {
                    throw new Error("Localiza√ß√£o n√£o encontrada. Verifique o nome e tente novamente.");
                }
                throw new Error("N√£o foi poss√≠vel buscar os dados do tempo. Tente novamente mais tarde.");
            }

            return await response.json();
        }

        /**
         * Processa os dados brutos da API (que v√™m em blocos de 3h) 
         * e os agrupa por dia, formatando-os para o nosso app.
         * @param {object} rawData - Dados brutos da API.
         * @returns {object} - Objeto formatado com locationName e array de forecast.
         */
        function processWeatherData(rawData) {
            const locationName = `${rawData.city.name}, ${rawData.city.country}`;
            const dailyData = {}; // Objeto para agrupar dados por dia

            // 1. Agrupa os blocos de 3 horas por dia
            rawData.list.forEach(item => {
                const date = item.dt_txt.split(' ')[0]; // Pega a parte YYYY-MM-DD
                if (!dailyData[date]) {
                    dailyData[date] = [];
                }
                dailyData[date].push(item);
            });

            // 2. Processa os dados agrupados para encontrar o resumo de cada dia
            const forecast = [];
            const weekdays = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S√°b"];

            for (const date in dailyData) {
                const dayChunks = dailyData[date];

                // Encontra min/max das temperaturas do dia
                const temp_max = Math.max(...dayChunks.map(chunk => chunk.main.temp_max));
                const temp_min = Math.min(...dayChunks.map(chunk => chunk.main.temp_min));
                
                // Pega a maior probabilidade de precipita√ß√£o (pop) do dia
                const precipitation = Math.max(...dayChunks.map(chunk => chunk.pop)); // Valor de 0 a 1

                // Pega a maior velocidade de vento do dia (convertido de m/s para km/h)
                const wind_speed_ms = Math.max(...dayChunks.map(chunk => chunk.wind.speed));
                const wind_speed_kmh = wind_speed_ms * 3.6;

                // Pega a menor visibilidade do dia (em metros)
                const visibility_m = Math.min(...dayChunks.map(chunk => chunk.visibility));

                // Pega a condi√ß√£o do tempo do meio-dia (ou o primeiro bloco, se n√£o houver)
                const middayChunk = dayChunks.find(chunk => chunk.dt_txt.includes("12:00:00")) || dayChunks[0];
                let condition = middayChunk.weather[0].description;
                condition = condition.charAt(0).toUpperCase() + condition.slice(1); // Capitaliza

                // Formata data e dia da semana
                const dateObj = new Date(`${date}T12:00:00`); // Usa T12:00 para evitar problemas de fuso
                const formattedDate = dateObj.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
                const weekday = weekdays[dateObj.getDay()];

                forecast.push({
                    date: formattedDate,
                    weekday: weekday,
                    condition: condition,
                    temp_max: Math.round(temp_max),
                    temp_min: Math.round(temp_min),
                    precipitation: Math.round(precipitation * 100), // Converte para %
                    wind_speed: Math.round(wind_speed_kmh), // Converte para km/h
                    visibility: visibility_m // Adiciona visibilidade em metros
                });
            }

            // Ajusta o primeiro dia para "Hoje"
            if (forecast.length > 0) {
                const today = new Date();
                const firstDate = new Date(`${Object.keys(dailyData)[0]}T12:00:00`);
                if (today.getDate() === firstDate.getDate()) {
                    forecast[0].weekday = "Hoje";
                }
            }

            return { locationName, forecast };
        }


        /**
         * Retorna um emoji com base na condi√ß√£o do tempo (descri√ß√µes do OWM).
         * @param {string} condition - A descri√ß√£o da condi√ß√£o (em portugu√™s).
         * @returns {string} - Um emoji.
         */
        function getWeatherIcon(condition) {
            const cond = condition.toLowerCase();
            
            if (cond.includes("trovoada")) return "‚õàÔ∏è";
            if (cond.includes("chuva forte") || cond.includes("chuva extrema")) return "üåßÔ∏è";
            if (cond.includes("chuva")) return "üå¶Ô∏è"; // Inclui leve, moderada
            if (cond.includes("neve")) return "‚ùÑÔ∏è";
            if (cond.includes("n√©voa") || cond.includes("neblina")) return "üå´Ô∏è";
            if (cond.includes("c√©u limpo")) return "‚òÄÔ∏è";
            if (cond.includes("poucas nuvens")) return "üå§Ô∏è";
            if (cond.includes("nuvens dispersas")) return "‚õÖ";
            if (cond.includes("nublado")) return "‚òÅÔ∏è";
            
            return "üåç"; // Padr√£o
        }

        /**
         * Retorna a categoria da visibilidade (Boa, Moderada, Baixa).
         * @param {number} visibility_m - Visibilidade em metros.
         * @returns {string} - A categoria.
         */
        function getVisibilityCategory(visibility_m) {
            if (visibility_m < 2000) return "Baixa";
            if (visibility_m < 5000) return "Moderada";
            return "Boa";
        }

        /**
         * Define a recomenda√ß√£o para a aula pr√°tica com base nos crit√©rios.
         * Esta fun√ß√£o √© a mesma que voc√™ selecionou, mas agora adaptada
         * para as descri√ß√µes em portugu√™s do OWM.
         * @param {object} day - Dados da previs√£o do dia.
         * @returns {object} - Objeto com texto e cores da recomenda√ß√£o.
         */
        function getRecommendation(day) {
            // Apenas extrai os dados necess√°rios para a nova l√≥gica
            const { wind_speed, condition } = day;
            const cond = condition.toLowerCase();

            // --- L√ìGICA BASEADA NA NOVA TABELA SIMPLIFICADA ---

            // 1. Crit√©rios para "Cr√≠tico"
            // "Chuva forte" (incluindo trovoada, etc.) OU "vento > 30km/h"
            const isBadWeather = cond.includes("forte") || cond.includes("trovoada") || cond.includes("extrema") || cond.includes("tempestade");
            
            if (isBadWeather || wind_speed > 30) {
                return {
                    text: "Cr√≠tico",
                    bgColor: "bg-red-100",
                    textColor: "text-red-800",
                    borderColor: "border-red-400"
                };
            }

            // 2. Crit√©rios para "Moderado"
            // "Nublado" OU "chuva leve" (qualquer chuva que n√£o seja "forte")
            const isCloudy = cond.includes("nublado") || cond.includes("nuvens dispersas");
            // Pega "chuva", "chuva leve", "chuva moderada", mas n√£o "chuva forte" (j√° pego acima)
            const isLightRain = cond.includes("chuva") && !isBadWeather; 

            if (isCloudy || isLightRain) {
                return {
                    text: "Moderado",
                    bgColor: "bg-yellow-100",
                    textColor: "text-yellow-800",
                    borderColor: "border-yellow-400"
                };
            }
            
            // 3. Crit√©rios para "Ideal"
            // "Sol" (c√©u limpo, poucas nuvens) E "vento < 15 km/h"
            const isSunny = cond.includes("c√©u limpo") || cond.includes("poucas nuvens") || cond.includes("sol");
            
            if (isSunny && wind_speed < 15) {
                return {
                    text: "Ideal",
                    bgColor: "bg-green-100",
                    textColor: "text-green-800",
                    borderColor: "border-green-400"
                };
            }

            // 4. Caso Padr√£o (Se n√£o se encaixar em nada, ex: n√©voa, ou sol com vento > 15)
            // A tabela n√£o cobre todas as possibilidades.
            // Vamos classificar casos n√£o definidos (como "n√©voa" ou "sol com vento de 20km/h") como "Moderado".
            return {
                text: "Moderado",
                bgColor: "bg-yellow-100",
                textColor: "text-yellow-800",
                borderColor: "border-yellow-400"
            };
        }

    </script>
</body>
</html>
